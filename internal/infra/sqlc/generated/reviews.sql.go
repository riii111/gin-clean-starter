// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reviews.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (
    user_id,
    resource_id,
    reservation_id,
    rating,
    comment
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_id, resource_id, reservation_id, rating, comment, created_at, updated_at
`

type CreateReviewParams struct {
	UserID        uuid.UUID `json:"user_id"`
	ResourceID    uuid.UUID `json:"resource_id"`
	ReservationID uuid.UUID `json:"reservation_id"`
	Rating        int32     `json:"rating"`
	Comment       string    `json:"comment"`
}

func (q *Queries) CreateReview(ctx context.Context, db DBTX, arg CreateReviewParams) (Reviews, error) {
	row := db.QueryRow(ctx, createReview,
		arg.UserID,
		arg.ResourceID,
		arg.ReservationID,
		arg.Rating,
		arg.Comment,
	)
	var i Reviews
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews WHERE id = $1
`

func (q *Queries) DeleteReview(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteReview, id)
	return err
}

const getResourceRatingStats = `-- name: GetResourceRatingStats :one
SELECT 
  resource_id,
  total_reviews,
  average_rating,
  rating_1_count,
  rating_2_count,
  rating_3_count,
  rating_4_count,
  rating_5_count,
  updated_at
FROM resource_rating_stats
WHERE resource_id = $1
`

func (q *Queries) GetResourceRatingStats(ctx context.Context, db DBTX, resourceID uuid.UUID) (ResourceRatingStats, error) {
	row := db.QueryRow(ctx, getResourceRatingStats, resourceID)
	var i ResourceRatingStats
	err := row.Scan(
		&i.ResourceID,
		&i.TotalReviews,
		&i.AverageRating,
		&i.Rating1Count,
		&i.Rating2Count,
		&i.Rating3Count,
		&i.Rating4Count,
		&i.Rating5Count,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByID = `-- name: GetReviewByID :one
SELECT id, user_id, resource_id, reservation_id, rating, comment, created_at, updated_at FROM reviews WHERE id = $1
`

func (q *Queries) GetReviewByID(ctx context.Context, db DBTX, id uuid.UUID) (Reviews, error) {
	row := db.QueryRow(ctx, getReviewByID, id)
	var i Reviews
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewViewByID = `-- name: GetReviewViewByID :one
SELECT 
  r.id,
  r.user_id,
  u.email AS user_email,
  r.resource_id,
  res.name AS resource_name,
  r.reservation_id,
  r.rating,
  r.comment,
  r.created_at,
  r.updated_at
FROM reviews r
JOIN users u ON r.user_id = u.id
JOIN resources res ON r.resource_id = res.id
WHERE r.id = $1
`

type GetReviewViewByIDRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        uuid.UUID          `json:"user_id"`
	UserEmail     string             `json:"user_email"`
	ResourceID    uuid.UUID          `json:"resource_id"`
	ResourceName  string             `json:"resource_name"`
	ReservationID uuid.UUID          `json:"reservation_id"`
	Rating        int32              `json:"rating"`
	Comment       string             `json:"comment"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetReviewViewByID(ctx context.Context, db DBTX, id uuid.UUID) (GetReviewViewByIDRow, error) {
	row := db.QueryRow(ctx, getReviewViewByID, id)
	var i GetReviewViewByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserEmail,
		&i.ResourceID,
		&i.ResourceName,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewsByResourceFirstPage = `-- name: GetReviewsByResourceFirstPage :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.resource_id = $1
  AND ($3 IS NULL OR r.rating >= $3)
  AND ($4 IS NULL OR r.rating <= $4)
ORDER BY r.created_at DESC, r.id DESC
LIMIT $2
`

type GetReviewsByResourceFirstPageParams struct {
	ResourceID uuid.UUID   `json:"resource_id"`
	Limit      int32       `json:"limit"`
	MinRating  interface{} `json:"min_rating"`
	MaxRating  interface{} `json:"max_rating"`
}

type GetReviewsByResourceFirstPageRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByResourceFirstPage(ctx context.Context, db DBTX, arg GetReviewsByResourceFirstPageParams) ([]GetReviewsByResourceFirstPageRow, error) {
	rows, err := db.Query(ctx, getReviewsByResourceFirstPage,
		arg.ResourceID,
		arg.Limit,
		arg.MinRating,
		arg.MaxRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByResourceFirstPageRow
	for rows.Next() {
		var i GetReviewsByResourceFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByResourceKeyset = `-- name: GetReviewsByResourceKeyset :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.resource_id = $1
  AND (r.created_at < $2 OR (r.created_at = $2 AND r.id < $3))
  AND ($5 IS NULL OR r.rating >= $5)
  AND ($6 IS NULL OR r.rating <= $6)
ORDER BY r.created_at DESC, r.id DESC
LIMIT $4
`

type GetReviewsByResourceKeysetParams struct {
	ResourceID uuid.UUID          `json:"resource_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	ID         uuid.UUID          `json:"id"`
	Limit      int32              `json:"limit"`
	MinRating  interface{}        `json:"min_rating"`
	MaxRating  interface{}        `json:"max_rating"`
}

type GetReviewsByResourceKeysetRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByResourceKeyset(ctx context.Context, db DBTX, arg GetReviewsByResourceKeysetParams) ([]GetReviewsByResourceKeysetRow, error) {
	rows, err := db.Query(ctx, getReviewsByResourceKeyset,
		arg.ResourceID,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
		arg.MinRating,
		arg.MaxRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByResourceKeysetRow
	for rows.Next() {
		var i GetReviewsByResourceKeysetRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserFirstPage = `-- name: GetReviewsByUserFirstPage :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.user_id = $1
ORDER BY r.created_at DESC, r.id DESC
LIMIT $2
`

type GetReviewsByUserFirstPageParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

type GetReviewsByUserFirstPageRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByUserFirstPage(ctx context.Context, db DBTX, arg GetReviewsByUserFirstPageParams) ([]GetReviewsByUserFirstPageRow, error) {
	rows, err := db.Query(ctx, getReviewsByUserFirstPage, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserFirstPageRow
	for rows.Next() {
		var i GetReviewsByUserFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserKeyset = `-- name: GetReviewsByUserKeyset :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.user_id = $1
  AND (r.created_at < $2 OR (r.created_at = $2 AND r.id < $3))
ORDER BY r.created_at DESC, r.id DESC
LIMIT $4
`

type GetReviewsByUserKeysetParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ID        uuid.UUID          `json:"id"`
	Limit     int32              `json:"limit"`
}

type GetReviewsByUserKeysetRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByUserKeyset(ctx context.Context, db DBTX, arg GetReviewsByUserKeysetParams) ([]GetReviewsByUserKeysetRow, error) {
	rows, err := db.Query(ctx, getReviewsByUserKeyset,
		arg.UserID,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserKeysetRow
	for rows.Next() {
		var i GetReviewsByUserKeysetRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReview = `-- name: UpdateReview :exec
UPDATE reviews
SET
    rating = $2,
    comment = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReviewParams struct {
	ID      uuid.UUID `json:"id"`
	Rating  int32     `json:"rating"`
	Comment string    `json:"comment"`
}

func (q *Queries) UpdateReview(ctx context.Context, db DBTX, arg UpdateReviewParams) error {
	_, err := db.Exec(ctx, updateReview, arg.ID, arg.Rating, arg.Comment)
	return err
}
