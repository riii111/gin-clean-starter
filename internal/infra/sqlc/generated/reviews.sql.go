// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reviews.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const applyResourceRatingStatsOnCreate = `-- name: ApplyResourceRatingStatsOnCreate :exec
INSERT INTO resource_rating_stats (
  resource_id,
  total_reviews,
  average_rating,
  rating_1_count,
  rating_2_count,
  rating_3_count,
  rating_4_count,
  rating_5_count,
  updated_at
)
VALUES (
  $1::uuid,
  1,
  ($2::int)::numeric,
  (CASE WHEN $2::int = 1 THEN 1 ELSE 0 END),
  (CASE WHEN $2::int = 2 THEN 1 ELSE 0 END),
  (CASE WHEN $2::int = 3 THEN 1 ELSE 0 END),
  (CASE WHEN $2::int = 4 THEN 1 ELSE 0 END),
  (CASE WHEN $2::int = 5 THEN 1 ELSE 0 END),
  NOW()
)
ON CONFLICT (resource_id) DO UPDATE SET
  total_reviews = resource_rating_stats.total_reviews + 1,
  average_rating = ROUND(((resource_rating_stats.average_rating * resource_rating_stats.total_reviews) + ($2::int)::numeric) / (resource_rating_stats.total_reviews + 1), 2),
  rating_1_count = resource_rating_stats.rating_1_count + (CASE WHEN $2::int = 1 THEN 1 ELSE 0 END),
  rating_2_count = resource_rating_stats.rating_2_count + (CASE WHEN $2::int = 2 THEN 1 ELSE 0 END),
  rating_3_count = resource_rating_stats.rating_3_count + (CASE WHEN $2::int = 3 THEN 1 ELSE 0 END),
  rating_4_count = resource_rating_stats.rating_4_count + (CASE WHEN $2::int = 4 THEN 1 ELSE 0 END),
  rating_5_count = resource_rating_stats.rating_5_count + (CASE WHEN $2::int = 5 THEN 1 ELSE 0 END),
  updated_at = NOW()
`

type ApplyResourceRatingStatsOnCreateParams struct {
	ResourceID uuid.UUID `json:"resource_id"`
	Rating     int32     `json:"rating"`
}

func (q *Queries) ApplyResourceRatingStatsOnCreate(ctx context.Context, db DBTX, arg ApplyResourceRatingStatsOnCreateParams) error {
	_, err := db.Exec(ctx, applyResourceRatingStatsOnCreate, arg.ResourceID, arg.Rating)
	return err
}

const applyResourceRatingStatsOnDelete = `-- name: ApplyResourceRatingStatsOnDelete :exec
UPDATE resource_rating_stats
SET
  total_reviews = GREATEST(total_reviews - 1, 0),
  average_rating = CASE
    WHEN total_reviews - 1 <= 0 THEN 0.00
    ELSE ROUND(((average_rating * total_reviews) - ($1::int)::numeric) / (total_reviews - 1), 2)
  END,
  rating_1_count = rating_1_count - (CASE WHEN $1::int = 1 THEN 1 ELSE 0 END),
  rating_2_count = rating_2_count - (CASE WHEN $1::int = 2 THEN 1 ELSE 0 END),
  rating_3_count = rating_3_count - (CASE WHEN $1::int = 3 THEN 1 ELSE 0 END),
  rating_4_count = rating_4_count - (CASE WHEN $1::int = 4 THEN 1 ELSE 0 END),
  rating_5_count = rating_5_count - (CASE WHEN $1::int = 5 THEN 1 ELSE 0 END),
  updated_at = NOW()
WHERE resource_id = $2::uuid
`

type ApplyResourceRatingStatsOnDeleteParams struct {
	Rating     int32     `json:"rating"`
	ResourceID uuid.UUID `json:"resource_id"`
}

func (q *Queries) ApplyResourceRatingStatsOnDelete(ctx context.Context, db DBTX, arg ApplyResourceRatingStatsOnDeleteParams) error {
	_, err := db.Exec(ctx, applyResourceRatingStatsOnDelete, arg.Rating, arg.ResourceID)
	return err
}

const applyResourceRatingStatsOnUpdate = `-- name: ApplyResourceRatingStatsOnUpdate :exec
UPDATE resource_rating_stats
SET
  average_rating = ROUND(((average_rating * total_reviews) - ($1::int)::numeric + ($2::int)::numeric) / NULLIF(total_reviews, 0), 2),
  rating_1_count = rating_1_count + (CASE WHEN $2::int = 1 THEN 1 ELSE 0 END) - (CASE WHEN $1::int = 1 THEN 1 ELSE 0 END),
  rating_2_count = rating_2_count + (CASE WHEN $2::int = 2 THEN 1 ELSE 0 END) - (CASE WHEN $1::int = 2 THEN 1 ELSE 0 END),
  rating_3_count = rating_3_count + (CASE WHEN $2::int = 3 THEN 1 ELSE 0 END) - (CASE WHEN $1::int = 3 THEN 1 ELSE 0 END),
  rating_4_count = rating_4_count + (CASE WHEN $2::int = 4 THEN 1 ELSE 0 END) - (CASE WHEN $1::int = 4 THEN 1 ELSE 0 END),
  rating_5_count = rating_5_count + (CASE WHEN $2::int = 5 THEN 1 ELSE 0 END) - (CASE WHEN $1::int = 5 THEN 1 ELSE 0 END),
  updated_at = NOW()
WHERE resource_id = $3::uuid
`

type ApplyResourceRatingStatsOnUpdateParams struct {
	OldRating  int32     `json:"old_rating"`
	NewRating  int32     `json:"new_rating"`
	ResourceID uuid.UUID `json:"resource_id"`
}

func (q *Queries) ApplyResourceRatingStatsOnUpdate(ctx context.Context, db DBTX, arg ApplyResourceRatingStatsOnUpdateParams) error {
	_, err := db.Exec(ctx, applyResourceRatingStatsOnUpdate, arg.OldRating, arg.NewRating, arg.ResourceID)
	return err
}

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (
    id,
    user_id,
    resource_id,
    reservation_id,
    rating,
    comment
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id
`

type CreateReviewParams struct {
	ID            uuid.UUID `json:"id"`
	UserID        uuid.UUID `json:"user_id"`
	ResourceID    uuid.UUID `json:"resource_id"`
	ReservationID uuid.UUID `json:"reservation_id"`
	Rating        int32     `json:"rating"`
	Comment       string    `json:"comment"`
}

func (q *Queries) CreateReview(ctx context.Context, db DBTX, arg CreateReviewParams) (uuid.UUID, error) {
	row := db.QueryRow(ctx, createReview,
		arg.ID,
		arg.UserID,
		arg.ResourceID,
		arg.ReservationID,
		arg.Rating,
		arg.Comment,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews WHERE id = $1
`

func (q *Queries) DeleteReview(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteReview, id)
	return err
}

const getResourceRatingStats = `-- name: GetResourceRatingStats :one
SELECT 
  resource_id,
  total_reviews,
  average_rating,
  rating_1_count,
  rating_2_count,
  rating_3_count,
  rating_4_count,
  rating_5_count,
  updated_at
FROM resource_rating_stats
WHERE resource_id = $1
`

func (q *Queries) GetResourceRatingStats(ctx context.Context, db DBTX, resourceID uuid.UUID) (ResourceRatingStats, error) {
	row := db.QueryRow(ctx, getResourceRatingStats, resourceID)
	var i ResourceRatingStats
	err := row.Scan(
		&i.ResourceID,
		&i.TotalReviews,
		&i.AverageRating,
		&i.Rating1Count,
		&i.Rating2Count,
		&i.Rating3Count,
		&i.Rating4Count,
		&i.Rating5Count,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewByID = `-- name: GetReviewByID :one
SELECT id, user_id, resource_id, reservation_id, rating, comment, created_at, updated_at FROM reviews WHERE id = $1
`

func (q *Queries) GetReviewByID(ctx context.Context, db DBTX, id uuid.UUID) (Reviews, error) {
	row := db.QueryRow(ctx, getReviewByID, id)
	var i Reviews
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResourceID,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewViewByID = `-- name: GetReviewViewByID :one
SELECT 
  r.id,
  r.user_id,
  u.email AS user_email,
  r.resource_id,
  res.name AS resource_name,
  r.reservation_id,
  r.rating,
  r.comment,
  r.created_at,
  r.updated_at
FROM reviews r
JOIN users u ON r.user_id = u.id
JOIN resources res ON r.resource_id = res.id
WHERE r.id = $1
`

type GetReviewViewByIDRow struct {
	ID            uuid.UUID          `json:"id"`
	UserID        uuid.UUID          `json:"user_id"`
	UserEmail     string             `json:"user_email"`
	ResourceID    uuid.UUID          `json:"resource_id"`
	ResourceName  string             `json:"resource_name"`
	ReservationID uuid.UUID          `json:"reservation_id"`
	Rating        int32              `json:"rating"`
	Comment       string             `json:"comment"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetReviewViewByID(ctx context.Context, db DBTX, id uuid.UUID) (GetReviewViewByIDRow, error) {
	row := db.QueryRow(ctx, getReviewViewByID, id)
	var i GetReviewViewByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserEmail,
		&i.ResourceID,
		&i.ResourceName,
		&i.ReservationID,
		&i.Rating,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReviewsByResourceFirstPage = `-- name: GetReviewsByResourceFirstPage :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.resource_id = $1
  AND ($3::int IS NULL OR r.rating >= $3::int)
  AND ($4::int IS NULL OR r.rating <= $4::int)
ORDER BY r.created_at DESC, r.id DESC
LIMIT $2
`

type GetReviewsByResourceFirstPageParams struct {
	ResourceID uuid.UUID   `json:"resource_id"`
	Limit      int32       `json:"limit"`
	MinRating  pgtype.Int4 `json:"min_rating"`
	MaxRating  pgtype.Int4 `json:"max_rating"`
}

type GetReviewsByResourceFirstPageRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByResourceFirstPage(ctx context.Context, db DBTX, arg GetReviewsByResourceFirstPageParams) ([]GetReviewsByResourceFirstPageRow, error) {
	rows, err := db.Query(ctx, getReviewsByResourceFirstPage,
		arg.ResourceID,
		arg.Limit,
		arg.MinRating,
		arg.MaxRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByResourceFirstPageRow
	for rows.Next() {
		var i GetReviewsByResourceFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByResourceKeyset = `-- name: GetReviewsByResourceKeyset :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.resource_id = $1
  AND (r.created_at < $2 OR (r.created_at = $2 AND r.id < $3))
  AND ($5::int IS NULL OR r.rating >= $5::int)
  AND ($6::int IS NULL OR r.rating <= $6::int)
ORDER BY r.created_at DESC, r.id DESC
LIMIT $4
`

type GetReviewsByResourceKeysetParams struct {
	ResourceID uuid.UUID          `json:"resource_id"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	ID         uuid.UUID          `json:"id"`
	Limit      int32              `json:"limit"`
	MinRating  pgtype.Int4        `json:"min_rating"`
	MaxRating  pgtype.Int4        `json:"max_rating"`
}

type GetReviewsByResourceKeysetRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByResourceKeyset(ctx context.Context, db DBTX, arg GetReviewsByResourceKeysetParams) ([]GetReviewsByResourceKeysetRow, error) {
	rows, err := db.Query(ctx, getReviewsByResourceKeyset,
		arg.ResourceID,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
		arg.MinRating,
		arg.MaxRating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByResourceKeysetRow
	for rows.Next() {
		var i GetReviewsByResourceKeysetRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserFirstPage = `-- name: GetReviewsByUserFirstPage :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.user_id = $1
ORDER BY r.created_at DESC, r.id DESC
LIMIT $2
`

type GetReviewsByUserFirstPageParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

type GetReviewsByUserFirstPageRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByUserFirstPage(ctx context.Context, db DBTX, arg GetReviewsByUserFirstPageParams) ([]GetReviewsByUserFirstPageRow, error) {
	rows, err := db.Query(ctx, getReviewsByUserFirstPage, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserFirstPageRow
	for rows.Next() {
		var i GetReviewsByUserFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewsByUserKeyset = `-- name: GetReviewsByUserKeyset :many
SELECT 
  r.id,
  u.email AS user_email,
  r.rating,
  r.comment,
  r.created_at
FROM reviews r
JOIN users u ON r.user_id = u.id
WHERE r.user_id = $1
  AND (r.created_at < $2 OR (r.created_at = $2 AND r.id < $3))
ORDER BY r.created_at DESC, r.id DESC
LIMIT $4
`

type GetReviewsByUserKeysetParams struct {
	UserID    uuid.UUID          `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ID        uuid.UUID          `json:"id"`
	Limit     int32              `json:"limit"`
}

type GetReviewsByUserKeysetRow struct {
	ID        uuid.UUID          `json:"id"`
	UserEmail string             `json:"user_email"`
	Rating    int32              `json:"rating"`
	Comment   string             `json:"comment"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetReviewsByUserKeyset(ctx context.Context, db DBTX, arg GetReviewsByUserKeysetParams) ([]GetReviewsByUserKeysetRow, error) {
	rows, err := db.Query(ctx, getReviewsByUserKeyset,
		arg.UserID,
		arg.CreatedAt,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsByUserKeysetRow
	for rows.Next() {
		var i GetReviewsByUserKeysetRow
		if err := rows.Scan(
			&i.ID,
			&i.UserEmail,
			&i.Rating,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalcResourceRatingStats = `-- name: RecalcResourceRatingStats :exec
INSERT INTO resource_rating_stats (
  resource_id,
  total_reviews,
  average_rating,
  rating_1_count,
  rating_2_count,
  rating_3_count,
  rating_4_count,
  rating_5_count,
  updated_at
)
SELECT
  $1 AS resource_id,
  COALESCE(COUNT(*), 0) AS total_reviews,
  COALESCE(ROUND(AVG(rating)::numeric, 2), 0.00) AS average_rating,
  COALESCE(SUM(CASE WHEN rating = 1 THEN 1 ELSE 0 END), 0) AS rating_1_count,
  COALESCE(SUM(CASE WHEN rating = 2 THEN 1 ELSE 0 END), 0) AS rating_2_count,
  COALESCE(SUM(CASE WHEN rating = 3 THEN 1 ELSE 0 END), 0) AS rating_3_count,
  COALESCE(SUM(CASE WHEN rating = 4 THEN 1 ELSE 0 END), 0) AS rating_4_count,
  COALESCE(SUM(CASE WHEN rating = 5 THEN 1 ELSE 0 END), 0) AS rating_5_count,
  NOW() AS updated_at
FROM reviews
WHERE resource_id = $1
ON CONFLICT (resource_id) DO UPDATE SET
  total_reviews = EXCLUDED.total_reviews,
  average_rating = EXCLUDED.average_rating,
  rating_1_count = EXCLUDED.rating_1_count,
  rating_2_count = EXCLUDED.rating_2_count,
  rating_3_count = EXCLUDED.rating_3_count,
  rating_4_count = EXCLUDED.rating_4_count,
  rating_5_count = EXCLUDED.rating_5_count,
  updated_at = NOW()
`

func (q *Queries) RecalcResourceRatingStats(ctx context.Context, db DBTX, resourceID uuid.UUID) error {
	_, err := db.Exec(ctx, recalcResourceRatingStats, resourceID)
	return err
}

const updateReview = `-- name: UpdateReview :exec
UPDATE reviews
SET
    rating = $2,
    comment = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReviewParams struct {
	ID      uuid.UUID `json:"id"`
	Rating  int32     `json:"rating"`
	Comment string    `json:"comment"`
}

func (q *Queries) UpdateReview(ctx context.Context, db DBTX, arg UpdateReviewParams) error {
	_, err := db.Exec(ctx, updateReview, arg.ID, arg.Rating, arg.Comment)
	return err
}
